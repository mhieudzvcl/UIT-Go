"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates.
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsContext = void 0;
const Configuration_1 = __importDefault(require("../config/Configuration"));
const Logger_1 = require("../utils/Logger");
const Validator_1 = require("../utils/Validator");
const MetricValues_1 = require("./MetricValues");
const StorageResolution_1 = require("./StorageResolution");
class MetricsContext {
    /**
     * Use this to create a new, empty context.
     */
    static empty() {
        return new MetricsContext();
    }
    /**
     * Constructor used to create child instances.
     * You should not use this constructor directly.
     * Instead, use createCopyWithContext() or empty().
     *
     * The reason for this is to avoid unexpected behavior when creating
     * MetricsContexts with defaultDimensions and existing dimensions.
     *
     * @param properties
     * @param dimensions
     */
    constructor(namespace, properties, dimensions, defaultDimensions, shouldUseDefaultDimensions, timestamp) {
        this.metrics = new Map();
        this.meta = {};
        this.shouldUseDefaultDimensions = true;
        this.metricNameAndResolutionMap = new Map();
        this.namespace = namespace || Configuration_1.default.namespace;
        this.properties = properties || {};
        this.dimensions = dimensions || [];
        this.timestamp = timestamp;
        this.meta.Timestamp = MetricsContext.resolveMetaTimestamp(timestamp);
        this.defaultDimensions = defaultDimensions || {};
        if (shouldUseDefaultDimensions != undefined) {
            this.shouldUseDefaultDimensions = shouldUseDefaultDimensions;
        }
    }
    static resolveMetaTimestamp(timestamp) {
        if (timestamp instanceof Date) {
            return timestamp.getTime();
        }
        else if (timestamp) {
            return timestamp;
        }
        else {
            return Date.now();
        }
    }
    setNamespace(value) {
        (0, Validator_1.validateNamespace)(value);
        this.namespace = value;
    }
    setProperty(key, value) {
        this.properties[key] = value;
    }
    setTimestamp(timestamp) {
        (0, Validator_1.validateTimestamp)(timestamp);
        this.timestamp = timestamp;
        this.meta.Timestamp = MetricsContext.resolveMetaTimestamp(timestamp);
    }
    /**
     * Sets default dimensions for the Context.
     * A dimension set will be created with just the default dimensions
     * and all calls to putDimensions will be prepended with the defaults.
     */
    setDefaultDimensions(dimensions) {
        (0, Logger_1.LOG)(`Received default dimensions`, dimensions);
        this.defaultDimensions = dimensions;
    }
    /**
     * Adds a new set of dimensions. Any time a new dimensions set
     * is added, the set is first prepended by the default dimensions.
     *
     * @param dimensions
     */
    putDimensions(incomingDimensionSet) {
        (0, Validator_1.validateDimensionSet)(incomingDimensionSet);
        // Duplicate dimensions sets are removed before being added to the end of the collection.
        // This ensures the latest dimension key-value is used as a target member on the root EMF node.
        // This operation is O(n^2), but acceptable given sets are capped at 10 dimensions
        const incomingDimensionSetKeys = Object.keys(incomingDimensionSet);
        this.dimensions = this.dimensions.filter((existingDimensionSet) => {
            const existingDimensionSetKeys = Object.keys(existingDimensionSet);
            if (existingDimensionSetKeys.length !== incomingDimensionSetKeys.length) {
                return true;
            }
            return !existingDimensionSetKeys.every((existingDimensionSetKey) => incomingDimensionSetKeys.includes(existingDimensionSetKey));
        });
        this.dimensions.push(incomingDimensionSet);
    }
    /**
     * Overwrite all dimensions.
     *
     * @param dimensionSets
     */
    setDimensions(dimensionSets, useDefault = false) {
        dimensionSets.forEach((dimensionSet) => (0, Validator_1.validateDimensionSet)(dimensionSet));
        this.shouldUseDefaultDimensions = useDefault;
        this.dimensions = dimensionSets;
    }
    /**
     * Reset all custom dimensions
     * @param useDefault Indicates whether default dimensions should be used
     */
    resetDimensions(useDefault) {
        this.shouldUseDefaultDimensions = useDefault;
        this.dimensions = [];
    }
    /**
     * Get the current dimensions.
     */
    getDimensions() {
        // caller has explicitly called setDimensions
        if (this.shouldUseDefaultDimensions === false) {
            return this.dimensions;
        }
        // if there are no default dimensions, return the custom dimensions
        if (Object.keys(this.defaultDimensions).length === 0) {
            return this.dimensions;
        }
        // if default dimensions have been provided, but no custom dimensions, use the defaults
        if (this.dimensions.length === 0) {
            return [this.defaultDimensions];
        }
        // otherwise, merge the dimensions
        // we do this on the read path because default dimensions
        // may get updated asynchronously by environment detection
        return this.dimensions.map((custom) => {
            return Object.assign(Object.assign({}, this.defaultDimensions), custom);
        });
    }
    putMetric(key, value, unit, storageResolution) {
        var _a;
        (0, Validator_1.validateMetric)(key, value, unit, storageResolution, this.metricNameAndResolutionMap);
        const currentMetric = this.metrics.get(key);
        if (currentMetric) {
            currentMetric.addValue(value);
        }
        else {
            this.metrics.set(key, new MetricValues_1.MetricValues(value, unit, storageResolution));
        }
        (_a = this.metricNameAndResolutionMap) === null || _a === void 0 ? void 0 : _a.set(key, storageResolution || StorageResolution_1.StorageResolution.Standard);
    }
    /**
     * Creates an independently flushable context.
     * Custom dimensions are preserved by default unless preserveDimensions parameter is set.
     * @param preserveDimensions Indicates whether custom dimensions should be preserved
     */
    createCopyWithContext(preserveDimensions = true) {
        return new MetricsContext(this.namespace, Object.assign({}, this.properties), preserveDimensions ? Object.assign([], this.dimensions) : [], this.defaultDimensions, this.shouldUseDefaultDimensions, this.timestamp);
    }
}
exports.MetricsContext = MetricsContext;
